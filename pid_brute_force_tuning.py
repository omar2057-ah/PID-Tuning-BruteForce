# -*- coding: utf-8 -*-
"""PID Brute force tuning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HW3LDDkYhNor4VqrRJNTHkHK-yUx4LxJ
"""

!pip install control

import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
import control as c

kd = 0
kp = 0
ki = 0
Optimalise = np.zeros(729)
Optimalkd =  np.zeros(729)
Optimalkp =  np.zeros(729)
Optimalki =  np.zeros(729)
previse = 0
counter = 0
ise = 0
num = 0
counterarr = np.zeros(730)
isearr = np.zeros(730)

for i in np.arange(1,10):
      kp = i
      for j in np.arange(0.1,1,0.1):
          kd = j
          for z in np.arange(0.01,0.1,0.01):
                ki = z
                Input_step = np.ones((1,100))
                sys = c.tf([kd, kp, ki], [0.1, 1.1, (1.01+kd), (0.1+kp), ki])
                #print(sys)

                tout = np.linspace(0,50,100)
                tout, yout = c.step_response(sys, tout)
                error = Input_step - yout

                errorsq = np.power(error, 2)
                ise = np.sum(errorsq)

                Optimalise[counter] = ise
                Optimalkd[counter] = kd
                Optimalkp[counter] = kp
                Optimalki[counter] = ki

                counter +=1
                counterarr[counter]=counter
                isearr[counter]=ise
                previse = ise
                print("Step Response At Kd = ",kd,", Kp = ",kp, "Ki = ",ki)
                print("Integral Square Error = ", ise)
                plt.plot(tout, yout)
                plt.title('Step Response Curve')
                plt.ylabel('Step Response')
                plt.xlabel('Time')
                plt.show()

Optimumise = np.amin(Optimalise)
OpimumIndex = np.argmin(Optimalise)
Kdopt = Optimalkd[OpimumIndex]
Kpopt = Optimalkp[OpimumIndex]
Kiopt = Optimalkp[OpimumIndex]
print("Optimal Kd = ", Optimalkd[OpimumIndex])
print("Optimal Kp = ", Optimalkp[OpimumIndex])
print("Optimal Ki = ", Optimalki[OpimumIndex])
print("Optimal ise = ", Optimumise)
print("Number of iterations: ", counter)

sysopt = c.tf([0.9, 4.0, 0.09], [0.1, 1.1, (1.01+0.9), (0.1+4.0), 0.09])
toutopt = np.linspace(0,100,200)
toutopt, youtopt = c.step_response(sysopt, toutopt)
print("Optimum Step Response: ")
plt.plot(toutopt, youtopt)
plt.title('Optimum Step Response')
plt.ylabel('Step Response')
plt.xlabel('Time')
plt.show()
print("Integral Square Error Vs Index Number")
plt.plot(counterarr, isearr)
plt.title('Integral Square Error Vs Index Number')
plt.ylabel('Integral Square Error')
plt.xlabel('Iteration Number')
plt.show()